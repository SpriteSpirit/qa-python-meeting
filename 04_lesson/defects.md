<h1>Баг отчеты</h1>

>Отчеты по методам класса StringUtils в порядке возрастания по уровню серьезности и приоритета.

<details>
  <summary>
    <strong>1. BR-1 Метод contains</strong>
  </summary>

### Заголовок:
Метод `contains` неправильно обрабатывает поиск подстроки

### Приоритет:
Minor

### Серьезность:
S3

### Предусловия:
- Класс `StringUtils`
- Метод `contains(string: str, symbol: str)`

### Фактический результат:
Метод находит подстроку любой длины:
`contains("hello", "ell")` возвращает `True`

### Ожидаемый результат:
Согласно документации, метод должен искать только одиночный символ:
`contains("hello", "ell")` должен возвращать `False` или вызывать `ValueError`

### Шаги воспроизведения:
1. Создать экземпляр класса: `string_utils = StringUtils()`
2. Вызвать метод contains: `result = string_utils.contains("hello", "ell")`
3. Вывести результат в консоль: `print(result) # True`

>### Дополнительно:
>В документации метода указано "`symbol` - искомый символ", что подразумевает поиск одного символа, а не подстроки.

</details>

<details>
  <summary>
    <strong>2. BR-2 Метод delete_symbol</strong>
  </summary>

### Заголовок:
Метод `delete_symbol` не соответствует своей документации

### Приоритет:
Minor

### Серьезность:
S3

### Предусловия:
- Класс `StringUtils`
- Метод `delete_symbol(string: str, symbol: str)`

### Фактический результат:
В документации указано "Удаляет все подстроки", но в примерах и названии метода используется термин "символ"

### Ожидаемый результат:
Документация должна быть согласована с реальным поведением метода:
- Либо метод должен работать только с символами
- Либо документация должна чётко указывать на работу с подстроками

>### Примечание:
>Сейчас есть несоответствие между:
>- Названием метода (symbol предполагает один символ)
>- Документацией (упоминаются подстроки)
>- Примерами (показаны оба варианта использования)
</details>

<details>
  <summary>
    <strong>3. BR-3 Метод list_to_string</strong>
  </summary>

### Заголовок:
Метод `list_to_string` не проверяет типы входных данных

### Приоритет:
Trivial

### Серьезность:
S3

### Предусловия:
- Класс `StringUtils`
- Метод `list_to_string(lst: list, joiner=", ")`

### Фактический результат:
Метод принимает тип данных строк:
- Строки обрабатываются как список символов
- Нет проверки типа разделителя

### Ожидаемый результат:
Метод должен:
- Принимать только списки (list)
- Проверять тип разделителя (str)
- Вызывать TypeError при неверных типах данных

### Шаги воспроизведения:
1. Создать экземпляр класса: `string_utils = StringUtils()`
2. Вызвать метод list_to_string для передачи строки: `result_str = string_utils.list_to_string("abc")  # Работает со строкой как со списком`
3. Вывести результат в консоль: `print(result_str) # True`


>### Дополнительно:
>В документации метода указано "Преобразует список элементов в строку с указанным разделителем"
</details>

<details>
  <summary>
    <strong>4. BR-4 Метод capitilize</strong>
  </summary>

### Заголовок:
Опечатка в названии метода `capitalize`

### Приоритет:
Low

### Серьезность:
S5

### Фактический результат:
Метод называется capitilize (после 't' идет буква 'i')

### Ожидаемый результат:
Метод должен называться capitalize (вместо 'i' после 't' должна идти 'a')

>### Влияние:
>- Затрудняет читаемость кода
>- Может вызвать путаницу при использовании
>- Не соответствует общепринятому написанию

</details>

<details>
  <summary>
    <strong>5. BR-5 Методы класса StringUtils следует объявить как static</strong>
  </summary>

### Заголовок:
Методы класса `StringUtils` следует объявить как `static`

### Приоритет:
Low

### Серьезность:
S5

### Описание:
Все методы класса `StringUtils` не используют состояние объекта (`self`) кроме вызова других методов класса. 
Это указывает на то, что методы могут быть объявлены как статические, что даст следующие преимущества:

- Не требуется создание экземпляра класса для использования методов
- Улучшение читаемости кода (явное указание, что методы не зависят от состояния объекта)
- Небольшое улучшение производительности (нет необходимости передавать `self`)

### Фактический результат:
```python
class StringUtils:
    def capitalize(self, string: str) -> str:
        return string.capitalize()
    
    def trim(self, string: str) -> str:
        whitespace = " "
        while string.startswith(whitespace):
            string = string.removeprefix(whitespace)
        return string
```

### Ожидаемый результат:
```python
class StringUtils:
    @staticmethod
    def capitalize(string: str) -> str:
        return string.capitalize()
    
    @staticmethod
    def trim(string: str) -> str:
        whitespace = " "
        while string.startswith(whitespace):
            string = string.removeprefix(whitespace)
        return string
```

### Использование:
**До:**
```python
utils = StringUtils()
result = utils.trim("  text  ")
```

**После:**
```python
result = StringUtils.trim("  text  ")
```

> ### Примечание
> Изменение не влияет на функциональность, но улучшает дизайн кода и его использование.
</details>
  