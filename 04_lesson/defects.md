<h1>Баг отчеты</h1>

>Отчеты по методам класса StringUtils в порядке возрастания по уровню серьезности и приоритета.

<details>
  <summary>
    <strong>1. BR-1 Метод contains</strong>
  </summary>

### Заголовок:
Метод `contains` неправильно обрабатывает поиск подстроки

### Приоритет:
Minor

### Серьезность:
S3

### Предусловия:
- Класс `StringUtils`
- Метод `contains(string: str, symbol: str)`

### Фактический результат:
Метод находит подстроку любой длины:
`contains("hello", "ell")` возвращает `True`

### Ожидаемый результат:
Согласно документации, метод должен искать только одиночный символ:
`contains("hello", "ell")` должен возвращать `False` или вызывать `ValueError`

### Шаги воспроизведения:
1. Создать экземпляр класса: `string_utils = StringUtils()`
2. Вызвать метод contains: `result = string_utils.contains("hello", "ell")`
3. Вывести результат в консоль: `print(result) # True`

>### Дополнительно:
>В документации метода указано "`symbol` - искомый символ", что подразумевает поиск одного символа, а не подстроки.

</details>

<details>
  <summary>
    <strong>2. BR-2 Метод delete_symbol</strong>
  </summary>

### Заголовок:
Метод `delete_symbol` не соответствует своей документации

### Приоритет:
Minor

### Серьезность:
S3

### Предусловия:
- Класс `StringUtils`
- Метод `delete_symbol(string: str, symbol: str)`

### Фактический результат:
В документации указано "Удаляет все подстроки", но в примерах и названии метода используется термин "символ"

### Ожидаемый результат:
Документация должна быть согласована с реальным поведением метода:
- Либо метод должен работать только с символами
- Либо документация должна чётко указывать на работу с подстроками

>### Примечание:
>Сейчас есть несоответствие между:
>- Названием метода (symbol предполагает один символ)
>- Документацией (упоминаются подстроки)
>- Примерами (показаны оба варианта использования)
</details>

<details>
  <summary>
    <strong>3. BR-3 Метод list_to_string</strong>
  </summary>

### Заголовок:
Метод `list_to_string` не проверяет типы входных данных

### Приоритет:
Trivial

### Серьезность:
S3

### Предусловия:
- Класс `StringUtils`
- Метод `list_to_string(lst: list, joiner=", ")`

### Фактический результат:
Метод принимает тип данных строк:
- Строки обрабатываются как список символов
- Нет проверки типа разделителя

### Ожидаемый результат:
Метод должен:
- Принимать только списки (list)
- Проверять тип разделителя (str)
- Вызывать TypeError при неверных типах данных

### Шаги воспроизведения:
1. Создать экземпляр класса: `string_utils = StringUtils()`
2. Вызвать метод list_to_string для передачи строки: `result_str = string_utils.list_to_string("abc")  # Работает со строкой как со списком`
3. Вывести результат в консоль: `print(result_str) # True`


>### Дополнительно:
>В документации метода указано "Преобразует список элементов в строку с указанным разделителем"
</details>

<details>
  <summary>
    <strong>4. BR-4 Метод capitilize</strong>
  </summary>

### Заголовок:
Опечатка в названии метода `capitalize`

### Приоритет:
Low

### Серьезность:
S5

### Фактический результат:
Метод называется capitilize (после 't' идет буква 'i')

### Ожидаемый результат:
Метод должен называться capitalize (вместо 'i' после 't' должна идти 'a')

>### Влияние:
>- Затрудняет читаемость кода
>- Может вызвать путаницу при использовании
>- Не соответствует общепринятому написанию

</details>

  